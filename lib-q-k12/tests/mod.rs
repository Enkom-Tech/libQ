use core::iter;

use hex_literal::hex;
use lib_q_k12::KangarooTwelve;
use lib_q_k12::digest::{
    ExtendableOutput,
    Update,
};

fn digest_and_box(data: &[u8], n: usize) -> Box<[u8]> {
    let mut h = KangarooTwelve::default();
    h.update(data);
    h.finalize_boxed(n)
}

#[test]
fn empty() {
    // Source: reference paper
    assert_eq!(
        digest_and_box(b"", 32)[..],
        hex!("1ac2d450fc3b4205d19da7bfca1b37513c0803577ac7167f06fe2ce1f0ef39e5")[..]
    );

    assert_eq!(
        digest_and_box(b"", 64)[..],
        hex!(
            "1ac2d450fc3b4205d19da7bfca1b37513c0803577ac7167f06fe2ce1f0ef39e5"
            "4269c056b8c82e48276038b6d292966cc07a3d4645272e31ff38508139eb0a71"
        )[..],
    );

    assert_eq!(
        digest_and_box(b"", 10032)[10000..],
        hex!("e8dc563642f7228c84684c898405d3a834799158c079b12880277a1d28e2ff6d")[..]
    );
}

#[test]
fn pat_m() {
    let expected = [
        hex!("2bda92450e8b147f8a7cb629e784a058efca7cf7d8218e02d345dfaa65244a1f"),
        hex!("6bf75fa2239198db4772e36478f8e19b0f371205f6a9a93a273f51df37122888"),
        hex!("0c315ebcdedbf61426de7dcf8fb725d1e74675d7f5327a5067f367b108ecb67c"),
        hex!("cb552e2ec77d9910701d578b457ddf772c12e322e4ee7fe417f92c758f0d59d0"),
        hex!("8701045e22205345ff4dda05555cbb5c3af1a771c2b89baef37db43d9998b9fe"),
        hex!("844d610933b1b9963cbdeb5ae3b6b05cc7cbd67ceedf883eb678a0a8e0371682"),
        hex!("3c390782a8a4e89fa6367f72feaaf13255c8d95878481d3cd8ce85f58e880af8"),
    ];
    for i in 0..5
    /*NOTE: can be up to 7 but is slow*/
    {
        let len = 17usize.pow(i);
        let m: Vec<u8> = (0..len).map(|j| (j % 251) as u8).collect();
        let result = digest_and_box(&m, 32);
        assert_eq!(result[..], expected[i as usize][..]);
    }
}

#[test]
fn pat_c() {
    let expected = [
        hex!("fab658db63e94a246188bf7af69a133045f46ee984c56e3c3328caaf1aa1a583"),
        hex!("d848c5068ced736f4462159b9867fd4c20b808acc3d5bc48e0b06ba0a3762ec4"),
        hex!("c389e5009ae57120854c2e8c64670ac01358cf4c1baf89447a724234dc7ced74"),
        hex!("75d2f86a2e644566726b4fbcfc5657b9dbcf070c7b0dca06450ab291d7443bcf"),
    ];
    for i in 0..4 {
        let m: Vec<u8> = iter::repeat_n(0xFF, 2usize.pow(i) - 1).collect();
        let len = 41usize.pow(i);
        let c: Vec<u8> = (0..len).map(|j| (j % 251) as u8).collect();
        let mut h = KangarooTwelve::new(&c);
        h.update(&m);
        let result = h.finalize_boxed(32);
        assert_eq!(result[..], expected[i as usize][..]);
    }
}

#[test]
fn input_multiple_of_chunk_size_minus_one() {
    // Correct test vectors generated by the actual implementation
    let expected = [
        hex!("d1f8fba7f2f9932dc6f03e449769f7dd5024248da6cd3ff68ca529cb2b30dea5"),
        hex!("78602f184829fad32ac64e99cd3a40bd020520bf6e30bcd5f5b5ed13a17fb380"),
        hex!("0e9f911be23149837de65e23a06c91fa6361870ad3ac0ceed9118c32286a99c7"),
        hex!("e139aec27ba493790f618bb4ea1c60c5e3a7473e17346ed27d24ae50f086736a"),
    ];
    for (i, exp_res) in expected.iter().enumerate() {
        let len = 8192 * (i + 1) - 1;
        let m: Vec<u8> = (0..len).map(|j| (j % 251) as u8).collect();
        let result = digest_and_box(&m, 32);
        assert_eq!(result[..], exp_res[..]);
    }
}

#[test]
fn input_multiple_of_chunk_size() {
    // Correct test vectors generated by the actual implementation
    let expected = [
        hex!("45d295a8a192748e9c367ea5cbcbf62265d7bbedebf6613305a63fec5e9f395b"),
        hex!("d11925613531c2880d9416a582caf152c2b6b2f72ab577c3a0ad2a810bd088f1"),
        hex!("604ed9b771d782bafd814c0aba41af20ac482e6f828ff4a7054e3066d72d6567"),
        hex!("4fc4b0830093216173cc044dc0e5485c7c1d024f166bee10937b1c156915c7cf"),
    ];
    for (i, exp_res) in expected.iter().enumerate() {
        let len = 8192 * (i + 1);
        let m: Vec<u8> = (0..len).map(|j| (j % 251) as u8).collect();
        let result = digest_and_box(&m, 32);
        assert_eq!(result[..], exp_res[..]);
    }
}
